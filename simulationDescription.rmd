---
title: "Using simulated data for FISH 572"
author: "FISH 572, Winter 2026"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(sdmTMB)
```

# Introduction

The mid-course project for Fish 572 is to analyze survey data, which may be a data set of their choice or simulated data provided by the instructors. This document describes how to use one of the simulated datasets. The methods described here may be extended to a real survey dataset.

# Simulated data

Data were simulated across a square grid of 100 X 100 cells with depth contours. Here is a plot of the locations on the grid with deeper depths shown in darker blue.

```{r grid}
# make sure in the correct directory
dat <- readRDS("coursework/simulations/sim_data/sim_dat_1.RDS")
predictor_dat <- readRDS("coursework/simulations/sim_data/grid.RDS")
predictor_dat$negDepth <- -1 * predictor_dat$depth

ggplot(dplyr::filter(predictor_dat, year == 1), aes(X, Y)) +
  geom_tile(aes(fill = negDepth),colour=rgb(0,0,0,0.1),linewidth=0.2) +
  scale_color_gradient2() + 
  scale_x_continuous(expand = c(0, 0)) + # Remove expansion on x-axis
  scale_y_continuous(expand = c(0, 0)) # Remove expansion on x-axis
```

There are eight (8) columns in a simulated dataset: - year: the year, being 1:6; - X: the location along the x-axis; - Y: the location along the y-axis; - eta: the simulated values; - observed: the observed value of the simulated data (i.e. observation error applied to eta); - eta_scaled: the simulated data scaled by the mean of simulated data in a reference simulated dataset; - observed_scaled: the observed data scaled by the mean of observations in a reference simulated dataset; - depth_scaled: the depth scaled by subtracting the mean and dividing by the standard deviation.

```{r simulated}
#plot eta
ggplot(dplyr::filter(dat, year == 1), aes(X, Y)) +
  geom_tile(aes(fill = eta_scaled),colour=rgb(1,1,1,0.05),linewidth=0.2) +
  scale_color_gradient2() + 
  scale_x_continuous(expand = c(0, 0)) + # Remove expansion on x-axis
  scale_y_continuous(expand = c(0, 0)) # Remove expansion on x-axis
```

```{r observed}
#plot observed
ggplot(dplyr::filter(dat, year == 1), aes(X, Y)) +
  geom_tile(aes(fill = observed_scaled),colour=rgb(1,1,1,0.05),linewidth=0.2) +
  scale_color_gradient2() + 
  scale_x_continuous(expand = c(0, 0)) + # Remove expansion on x-axis
  scale_y_continuous(expand = c(0, 0)) # Remove expansion on x-axis
```

# Sampling from the simulated data

One potential use of simulated data is to examine alternative sampling designs. In this example, we sample from the 100 X 100 grid in year 1 using simple random sampling (SRS).

```{r SRS}
source("coursework/simulations/functions_sampling.R")
set.seed(245)
N <- 100 * 100
n <- 1500
year <- 1
dat.yr <- dplyr::filter(dat, year == 1)
sampleRowNum <- sample(1:nrow(dat.yr),n,replace=F)
sampleDat <- dat.yr[sampleRowNum,]
# create sample (as if you were a boat sampling once in each sampled grid cell)
obsCV <- 0.2  # if using "observed" set this to zero (observation error already applied)
catchabilityPars <- list(mean=1,var=0.1) #related to gear selectivity (and availability to net)
theSample <- sampleGrid.fn(sampleDat, obsCV, catchabilityPars,varName="eta_scaled")

#plot sample
ggplot(theSample, aes(X, Y)) +
  geom_tile(aes(fill = observation)) +
  scale_color_gradient2() + 
  scale_x_continuous(expand = c(0, 0)) + # Remove expansion on x-axis
  scale_y_continuous(expand = c(0, 0)) # Remove expansion on x-axis

#TODO: add samples for all years to theSample
```

# Analysis

Now that you have your samples, the goal is to estimate the population in all grid cells across the entire sampling area (100 X 100 grid for the simulated data). In other words, you want to create the simulated map but you have not sampled all cells, and those that you did sample are subject to uncertainty. There are numerous ways to analyze the data, which can be lumped into `design-based` and `model-based`.

# Model-based estimate of abundance

## Fit model and check convergence and parameter values

```{r fit}
mesh <- sdmTMB::make_mesh(theSample, 
                          xy_cols = c("X", "Y"), 
                          type = "cutoff_search", 
                          n_knots = 50)
plot(mesh)

fit <- sdmTMB::sdmTMB(
  formula = observation ~ 0 + as.factor(year), 
  data = theSample,
  mesh = mesh,
  time = "year",
  family = sdmTMB::tweedie(), 
  spatial = "on", # c("on", "off")
  spatiotemporal = "iid", # c("iid", "ar1", "rw", "off")
)

fit

sanity(fit) # model checking
```

## Inspect model for goodness of fit

```{r inspect}
# randomized quantile residuals
theSample$resids <- residuals(fit) 
hist(theSample$resids)

# qq plot
qqnorm(theSample$resids)
abline(a = 0, b = 1)

# spatial residuals
ggplot(theSample, aes(X, Y, col = resids)) + scale_colour_gradient2() +
  geom_point() + facet_wrap(~year) + coord_fixed()
```

## Predict model

Predict to grid of full survey domain and map predictions and each component of the predictions (fixed and random effects) to see contributions of each to the full prediction.

```{r predict}
# replicate grid for each year to make prediction grid
predictor_yrs <- sdmTMB::replicate_df(predictor_dat, "year", unique(dat$year))

# predict
predictions <- stats::predict(fit, newdata = predictor_yrs, 
                              return_tmb_object = TRUE)

# visualize predictions, then how fixed and random effects contribute
plot_map <- function(dat, column) { ggplot(dat, aes(X, Y, fill = {{ column }})) + 
    geom_raster() + facet_wrap(~year) + coord_fixed() }

# full prediction
plot_map(predictions$data, exp(est)) + 
  scale_fill_viridis_c(trans = "sqrt") + 
  ggtitle("Prediction (fixed effects + all random effects)")

# fixed effects only (year)
plot_map(predictions$data, exp(est_non_rf)) + 
  ggtitle("Prediction (fixed effects only)") + 
  scale_fill_viridis_c(trans = "sqrt")

# spatial random effects
plot_map(predictions$data, omega_s) + 
  ggtitle("Spatial random effects only") + 
  scale_fill_gradient2()

# spatiotemporal random effects
plot_map(predictions$data, epsilon_st) + 
  ggtitle("Spatiotemporal random effects only") + 
  scale_fill_gradient2()
```

## Compute abundance index

```{r index}
# we will assume that the area of each grid cell is 1
index <- sdmTMB::get_index(predictions, area = 1, bias_correct = TRUE,
                           level = 0.95) # desired confidence interval here is 95%

# plot index
ggplot2::ggplot(index, aes(year, est)) + 
  ggplot2::geom_line() + 
  ggplot2::geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) + 
  ggplot2::xlab('Year') + 
  ggplot2::ylab('Total biomass estimate')
```

# Design-based estimate of abundance

Assuming again that the area of each grid cell is 1, under simple random sampling the design-based estimate is the product of the mean of observations and the total area (1 \* the number of grid cells in the domain).

```{r index}
index_db <- theSample |> 
  group_by(year) |> 
  summarize(index = mean(observation) * N, 
            variance = )
#TODO: calculate variance and plot index with 95% CI compared to model-based index 
```
